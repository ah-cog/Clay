<!DOCTYPE html>
<html>
<head>
    <title>Looper</title>
    <link href="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.2/css/bootstrap-combined.min.css" rel="stylesheet">
    <script src="javascripts/acorn.js"></script>
    <script src="javascripts/interpreter.js"></script>
    <script src="javascripts/processing.js"></script> 
    <meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1">
    <link href='http://fonts.googleapis.com/css?family=Didact+Gothic' rel='stylesheet' type='text/css'>
    <style>

        html, body, #carousel, #carousel ul, #carousel li {
            min-height: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            position: relative;
        }

        #debug {
            position: fixed;
            background: #fff;
            padding: 5px;
            color: #000;
            top: 0;
            left: 0;
            z-index: 1337;
        }

        #carousel {
            background: silver;
            overflow: hidden;
            width:100%;
            -webkit-backface-visibility: hidden;
            -webkit-transform: translate3d(0,0,0) scale3d(1,1,1);
            -webkit-transform-style: preserve-3d;
        }

        #carousel ul.animate {
            -webkit-transition: all .3s;
            -moz-transition: all .3s;
            -o-transition: all .3s;
            transition: all .3s;
        }

        #carousel ul {
            transform: translate3d(0%,0,0) scale3d(1,1,1);
            -o-transform: translate3d(0%,0,0) scale3d(1,1,1);
            -ms-transform: translate3d(0%,0,0) scale3d(1,1,1);
            -moz-transform: translate3d(0%,0,0) scale3d(1,1,1);
            -webkit-transform: translate3d(0%,0,0) scale3d(1,1,1);
            overflow: hidden;
            -webkit-backface-visibility: hidden;
            -webkit-transform-style: preserve-3d;
        }

        #carousel ul {
            -webkit-box-shadow: 0 0 20px rgba(0,0,0,.2);
            box-shadow: 0 0 20px rgba(0,0,0,.2);
            position: relative;
        }

        #carousel li {
            float: left;
            overflow: hidden;
            -webkit-transform-style: preserve-3d;
            -webkit-transform: translate3d(0,0,0);
        }

        #carousel li h2 {
            color: #fff;
            font-size: 40px;
            text-align: center;
            position: absolute;
            top: 40%;
            left: 0;
            width: 100%;
            text-shadow: 0px 0px 0 rgba(0,0,0,.2);
            font-family: 'Didact Gothic', sans-serif;
        }

        #carousel li.pane1 { background: #F0F1F0; } // #42d692
        #carousel li.pane2 { background: #4986e7; }
        #carousel li.pane3 { background: #d06b64; }
        #carousel li.pane4 { background: #cd74e6; }
        #carousel li.pane5 { background: #9fe1e7; }





        .drag {
            position: absolute;
            left: 100px;
            top: 100px;
            background: #9fe1e7;
            border-radius: 50px;
            width: 100px;
            height: 100px;
        }

        .drag1 { background: #42d692; }
        .drag2 { background: #4986e7; }
        .drag3 { background: #d06b64; }
        .drag4 { background: #cd74e6; }
        .drag5 { background: #9fe1e7; }

    </style>



    
  <!-- Include Firebase -->
  <script src="https://cdn.firebase.com/v0/firebase.js"></script>

  <!-- Include ACE and its JavaScript mode and theme files -->
  <script src="ace/ace.js"></script>
  <script src="ace/mode-javascript.js"></script>
  <script src="ace/theme-textmate.js"></script>

  <!-- Include Firepad -->
  <script src="firepad.js"></script>
  <link rel="stylesheet" href="firepad.css" />

  <!-- Helper for generating URLs / Firebase references for example purposes.
       Not necessary in production apps. -->
  <script src="example-helper.js"></script>

  <style>
    html { height: 100%; }
    body { margin: 0; height: 100%; position: relative; }
    /* Height / width / positioning can be customized for your use case.
       For demo purposes, we make firepad fill the entire browser. */
    #firepad-container {
      position: absolute; left: 0; top: 0; bottom: 0; right: 0;
    }

    .firepad {
      /*width: 700px;*/
      height: 450px;
      background-color: #f62; /* dark orange background */
    }
  </style>
</head>

<body>

<!-- <h1>Drag the balls!</h1> -->

    

    <script>

       //$("body").append("<div id='overlay'><input type=\"button\" value=\"close\" onclick=\"$('#overlay').hide();\" /><div id=\"firepad-container\"></div></div>");

       // $("#overlay")
       //    .height(docHeight)
       //    .css({
       //       'opacity' : 0.3,
       //       'position': 'absolute',
       //       'top': 0,
       //       'left': 0,
       //       'background-color': '#333333',
       //       'width': '100%',
       //       'z-index': 5000
       //    });

        // $("#overlay").hide();
    </script>


    <script>
    window.onload = function() {
      //// Initialize Firebase.
      var firepadRef = getExampleRef();
      // TODO: Replace above line with:
      // var ref = new Firebase('<YOUR FIREBASE URL>');
  
      //// Create ACE
      var editor = ace.edit("firepad-container");
      editor.setTheme("ace/theme/textmate");
      var session = editor.getSession();
      session.setUseWrapMode(true);
      session.setUseWorker(false);
      session.setMode("ace/mode/javascript");
  
      //// Create Firepad.
      var firepad = Firepad.fromACE(firepadRef, editor);
      
      //// Initialize contents.
      firepad.on('ready', function() {
        if (firepad.isHistoryEmpty()) {
          firepad.setText('// JavaScript Editing with Firepad!\nfunction go() {\n  var message = "Hello, world.";\n  console.log(message);\n}');
        }
      });
    };
  </script>



    <!-- jQuery is just for the demo! Hammer.js works without jQuery :-) -->
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script>
    <script src="javascripts/modernizr.js"></script>

    <script>

        disableEventCreate = false;
        showPalette = false;

    </script>

    <!--<div id="debug">Log</div>-->

    <div id="carousel">
        <ul id="panes">

            <li class="pane1">
                <div id="overlay" style="width: 100%; height: 100%; position: relative; z-index: 5000;">
                    <input type="button" value="close" onclick="$('#overlay').hide();" />
                    <div id="firepad-container"></div>
                </div>
                <script>
                    $('#overlay').hide();
                </script>

                <canvas id="looperCanvas" style="width: 100%; height: 100%;"></canvas>
            </li>
<!-- 
            <li class="pane4"><h2>script on another module<h2></li>
            <li class="pane5"><h2>script on yet another module</h2></li>

            <li class="pane2">
                <canvas id="canvas2" style="width: 100%; height: 100%;"></canvas>
            </li>

            <li class="pane3">
              <div class="nodes" style="width:800px; margin:0 auto;">
                <div class="drag drag1"></div>
                <div class="drag drag2"></div>
                <div class="drag drag3"></div>
                <div class="drag drag4"></div>
                <div class="drag drag5"></div>
              </div>
            </li>
            <li class="pane4"><h2>..or drag...</h2></li>
            <li class="pane5"><h2>Dit is het einde!</h2></li> -->
        </ul>
    </div>



    <script src="javascripts/jquery.hammer.min.js"></script>

    <script>

    var debug_el = $("#debug");
    function debug(text) {
        debug_el.text(text);
    }


    /**
     * requestAnimationFrame and cancel polyfill
     */
    (function() {
        var lastTime = 0;
        var vendors = ['ms', 'moz', 'webkit', 'o'];
        for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
            window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
            window.cancelAnimationFrame =
                    window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
        }

        if (!window.requestAnimationFrame)
            window.requestAnimationFrame = function(callback, element) {
                var currTime = new Date().getTime();
                var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                var id = window.setTimeout(function() { callback(currTime + timeToCall); },
                        timeToCall);
                lastTime = currTime + timeToCall;
                return id;
            };

        if (!window.cancelAnimationFrame)
            window.cancelAnimationFrame = function(id) {
                clearTimeout(id);
            };
    }());


    /**
    * super simple carousel
    * animation between panes happens with css transitions
    */
    function Carousel(element)
    {
        var self = this;
        element = $(element);

        var container = $(">ul", element);
        var panes = $(">ul>li", element);

        var pane_width = 0;
        var pane_count = panes.length;

        var current_pane = 0;


        /**
         * initial
         */
        this.init = function() {
            setPaneDimensions();

            $(window).on("load resize orientationchange", function() {
                setPaneDimensions();
                //updateOffset();
            })
        };


        /**
         * set the pane dimensions and scale the container
         */
        function setPaneDimensions() {
            pane_width = element.width();
            panes.each(function() {
                $(this).width(pane_width);
            });
            container.width(pane_width*pane_count);
        };


        /**
         * show pane by index
         * @param   {Number}    index
         */
        this.showPane = function( index ) {
            // between the bounds
            index = Math.max(0, Math.min(index, pane_count-1));
            current_pane = index;

            var offset = -((100/pane_count)*current_pane);
            setContainerOffset(offset, true);
        };


        function setContainerOffset(percent, animate) {
            container.removeClass("animate");

            if(animate) {
                container.addClass("animate");
            }

            if(Modernizr.csstransforms3d) {
                container.css("transform", "translate3d("+ percent +"%,0,0) scale3d(1,1,1)");
            }
            else if(Modernizr.csstransforms) {
                container.css("transform", "translate("+ percent +"%,0)");
            }
            else {
                var px = ((pane_width*pane_count) / 100) * percent;
                container.css("left", px+"px");
            }
        }

        this.next = function() { return this.showPane(current_pane+1, true); };
        this.prev = function() { return this.showPane(current_pane-1, true); };



        function handleHammer(ev) {
            console.log(ev);
            // disable browser scrolling
            ev.gesture.preventDefault();

            if (!disableEventCreate) {

                switch(ev.type) {
                    case 'dragright':
                    case 'dragleft':
                        // stick to the finger
                        var pane_offset = -(100/pane_count)*current_pane;
                        var drag_offset = ((100/pane_width)*ev.gesture.deltaX) / pane_count;

                        // slow down at the first and last pane
                        if((current_pane == 0 && ev.gesture.direction == Hammer.DIRECTION_RIGHT) ||
                            (current_pane == pane_count-1 && ev.gesture.direction == Hammer.DIRECTION_LEFT)) {
                            drag_offset *= .4;
                        }

                        setContainerOffset(drag_offset + pane_offset);
                        break;

                    case 'swipeleft':
                        self.next();
                        ev.gesture.stopDetect();
                        break;

                    case 'swiperight':
                        self.prev();
                        ev.gesture.stopDetect();
                        break;

                    case 'release':
                        // more then 50% moved, navigate
                        if(Math.abs(ev.gesture.deltaX) > pane_width/2) {
                            if(ev.gesture.direction == 'right') {
                                self.prev();
                            } else {
                                self.next();
                            }
                        }
                        else {
                            self.showPane(current_pane, true);
                        }
                        break;
                }

            }
        }

        element.hammer({ drag_lock_to_axis: true })
            .on("release dragleft dragright swipeleft swiperight", handleHammer);
    }


    var carousel = new Carousel("#carousel");
    carousel.init();


    // $(".drag")
    //   .hammer({ drag_max_touches: 0 })
    //   .on("touch drag dragright dragleft", function(ev) {
    //     console.log("DRAG CIRCLE");

    //     var touches = ev.gesture.touches;

    //     for(var t=0,len=touches.length; t<len; t++) {
    //         var target = $(touches[t].target);
    //         target.css({
    //             zIndex: 1337,
    //             left: touches[t].pageX-50,
    //             top: touches[t].pageY-50
    //         });
    //     }

    //     ev.gesture.preventDefault();
    //     ev.stopPropagation();
    //     ev.gesture.stopPropagation();
    //     return;
    //   });


    </script>

    <script src="javascripts/ga.js"></script>



    <script type="application/processing" data-processing-target="looperCanvas">

        /*
        @pjs
        crisp=true;
        font=DidactGothic.ttf;
        */

    </script>

    <script>

    function Medium(options) {
        var defaults = {
            devices: []
        };
        var options = options || {};
        var options = $.extend({}, defaults, options);

        this.devices = [];
    }

    function EventLoop(options) {
        var defaults = {
            events: []
        };
        var options = options || {};
        var options = $.extend({}, defaults, options);

        this.events = options.events; // events on the event loop
    }

    function Event(options) {
        var defaults = {
            x: null,
            y: null,
            xTarget: null,
            yTarget: null,
            state: 'INVALID', // INVALID, FLOATING, MOVING, ENTANGLED, SEQUENCED
            //visible: true
            go: null
        };
        var options = options || {};
        var options = $.extend({}, defaults, options);

        this.x = options.x;
        this.y = options.y;

        this.xTarget = options.xTarget;
        this.yTarget = options.yTarget;

        this.state = options.state;

        this.go = options.go;

        //this.visible = options.visible;
    }




    function setupGestures(currentCanvas, device) {

        /**
         * Touch event handler
         * @param  {[type]} ev [description]
         * @return {[type]}    [description]
         */
        $(currentCanvas).hammer({ drag_max_touches: 0 }).on("touch", function(ev) {
            console.log("'touch' event!");

            var touches = ev.gesture.touches;

            //
            // Get the touched event node, if one exists
            // 
            var eventCount = device.processingInstance.eventLoop.events.length;

            for (var i = 0; i < eventCount; i++) {
                var loopEvent = device.processingInstance.eventLoop.events[i];
                if ((ev.gesture.center.pageX - 50 < loopEvent.x && loopEvent.x < ev.gesture.center.pageX + 50)
                    && (ev.gesture.center.pageY - 50 < loopEvent.y && loopEvent.y < ev.gesture.center.pageY + 50)) {

                    //loopEvent.visible = false;
                    loopEvent.state = 'MOVING';
                    disableEventCreate = true;

                    console.log("\tevent " + i);
                    break;
                }
            }

            //
            // Check of "go" button touched
            //
            
            if ((ev.gesture.center.pageX - 50 < (device.processingInstance.screenWidth / 2) && (device.processingInstance.screenWidth / 2) < ev.gesture.center.pageX + 50)
                && (ev.gesture.center.pageY - 50 < (device.processingInstance.screenHeight / 2) && (device.processingInstance.screenHeight / 2) < ev.gesture.center.pageY + 50)) {

                //console.log("go");
                device.processingInstance.getEventSequence();
            }

            //
            // Check if "script" button touched
            //
            
            if ((ev.gesture.center.pageX - 50 < (device.processingInstance.screenWidth / 2) && (device.processingInstance.screenWidth / 2) < ev.gesture.center.pageX + 50)
                && (ev.gesture.center.pageY - 50 < (device.processingInstance.screenHeight / 7 + 20) && (device.processingInstance.screenHeight / 7 + 20) < ev.gesture.center.pageY + 50)) {

                // Prompt for new script name
                var newScriptName = prompt("Type a name for this script", "script");
                if (newScriptName.length > 0) {
                    scriptName = newScriptName;
                }
            }

            ev.gesture.preventDefault();
            ev.stopPropagation();
            ev.gesture.stopPropagation();
            return;
        });

        $(currentCanvas).hammer({ drag_max_touches: 0 }).on("release", function(ev) {
            console.log("'release' event!");

            var touches = ev.gesture.touches;

            // Get the touched object, if one exists
            var eventCount = device.processingInstance.eventLoop.events.length;
            for (var i = 0; i < eventCount; i++) {
                var loopEvent = device.processingInstance.eventLoop.events[i];

                if (loopEvent.state === 'MOVING') {

                    // deltaX = ev.gesture.center.pageX - (screenWidth / 2);
                    // deltaY = ev.gesture.center.pageY - (screenHeight / 2);
                    // //angleInDegrees = Math.atan(deltaY / deltaX) * 180 / PI;
                    // angleInDegrees = Math.atan2(deltaY, deltaX); // * 180 / PI;

                    // x = screenWidth / 2 + (400 / 2) * Math.cos(angleInDegrees);
                    // y = screenHeight / 2 + (400 / 2) * Math.sin(angleInDegrees);

                    var distance = device.processingInstance.getDistanceFromEventLoop(loopEvent);
                    console.log(distance);

                    console.log('DISTANCE');
                    console.log(distance);

                    if (distance < 110) {
                        var nearestPosition = device.processingInstance.getNearestPositionOnEventLoop(ev.gesture.center.pageX, ev.gesture.center.pageY);
                        loopEvent.x = nearestPosition.x;
                        loopEvent.y = nearestPosition.y;
                        loopEvent.state = 'SEQUENCED';
                    } else {
                        loopEvent.state = 'FLOATING';
                    }

                    // TODO: Only show JS editor by default for new nodes
                    console.log("open editor!");
                    // $('#overlay').show(); // TODO: Append argument

                    disableEventCreate = false;

                    break;
                }
            }

            disableEventCreate = false;

            // ev.gesture.preventDefault();
            // ev.stopPropagation();
            // ev.gesture.stopPropagation();
            // return;
        });



        $(currentCanvas).hammer({ drag_max_touches: 0, hold_timeout: 200 }).on("hold", function(ev) {
            console.log("'hold' event!");

            if (!disableEventCreate) {
                disableEventCreate = true;

                var touches = ev.gesture.touches;

                // deltaX = ev.gesture.center.pageX - (screenWidth / 2);
                // deltaY = ev.gesture.center.pageY - (screenHeight / 2);
                // //angleInDegrees = Math.atan(deltaY / deltaX) * 180 / PI;
                // angleInDegrees = Math.atan2(deltaY, deltaX); // * 180 / PI;

                // x = screenWidth / 2 + (400 / 2) * Math.cos(angleInDegrees);
                // y = screenHeight / 2 + (400 / 2) * Math.sin(angleInDegrees);

                var nearestPosition = device.processingInstance.getNearestPositionOnEventLoop(ev.gesture.center.pageX, ev.gesture.center.pageY);

                // xPalette = device.processingInstance.mouseX;
                // yPalette = device.processingInstance.mouseY;
                // showPalette = true;

                var loopEvent = new Event({
                    x: ev.gesture.center.pageX,
                    y: ev.gesture.center.pageY,
                    xTarget: nearestPosition.x,
                    yTarget: nearestPosition.y
                });

                loopEvent.state = 'MOVING';
                device.processingInstance.eventLoop.events.push(loopEvent);
            }

            ev.gesture.preventDefault();
            ev.stopPropagation();
            ev.gesture.stopPropagation();
            return;
        });
    }


    devices = [];
    deviceCount = -1;

    /**
     * Add an expressive interface to a device.
     */
    function Device(options) {

        /** Set up object defaults */
        var defaults = {
            canvas: null, // Canvas instance
            // eventLoop: null
        };
        var options = options || {};
        var options = $.extend({}, defaults, options);

        if (options.canvas === null) {
            alert("No canvas specified.");
            return;
        }

        this.canvas = options.canvas;

        this.scriptName = "script";
        // this.disableEventCreate = false;
        this.showPalette = false;
        this.font = null;

        // this.canvas = options.canvas; // events on the event loop

        // if (this.canvas === null) {
        //     alert("No canvas specified.")
        //     return;
        // }

        /**
         * Create new canvas element for the device interface
         */

        // deviceCount = deviceCount + 1;
        // $('#panes').append('<li class="pane' + deviceCount + '"><canvas id="canvas' + deviceCount + '" style="width: 100%; height: 100%;"></canvas></li>');
        // canvas = "canvas" + deviceCount;
        // this.canvas = canvas; // hack hack hack

        /**
         * Processing sketch code
         */
        var deviceSketch = new Processing.Sketch(function(processing) {

            var backgroundColor = processing.color(Math.random() * 255, Math.random() * 255, Math.random() * 255);
            function generateRandomColor(red, green, blue) {
                // Random random = new Random();
                var randomRed = Math.random() * 255;
                var randomGreen = Math.random() * 255;
                var randomBlue = Math.random() * 255;

                // mix the color
                if (red !== null && green !== null && blue !== null) {
                    randomRed = (randomRed + red) / 2;
                    randomGreen = (randomGreen + green) / 2;
                    randomBlue = (randomBlue + blue) / 2;
                }

                // Color color = new Color(red, green, blue);
                var color = { red: randomRed, green: randomGreen, blue: randomBlue };
                return color;
            }
            var color = generateRandomColor(255, 255, 255);
            var backgroundColor = processing.color(color.red, color.green, color.blue);

            var scriptName = "script";

            processing.eventLoop = new EventLoop();

            // Override setup function
            processing.setup = function() {
                processing.size(processing.screenWidth, processing.screenHeight);

                this.font = processing.loadFont("DidactGothic.ttf");
            }

            // Override draw function, by default it will be called 60 times per second
            processing.draw = function() {

                function drawEventLoop() {

                    processing.pushMatrix();

                    // Draw the "loop" circular arc
                    processing.strokeWeight(1.0);
                    processing.stroke(65, 65, 65);
                    processing.noFill();
                    processing.smooth();
                    processing.arc(processing.screenWidth / 2, processing.screenHeight / 2, 400, 400, (-processing.PI/2) + 0.05*processing.PI, 1.45*processing.PI);

                    // Draw arrow
                    processing.translate(processing.screenWidth / 2, processing.screenHeight / 2);
                    processing.translate(-29, -198);
                    processing.rotate(-0.05*processing.PI);
                    processing.line(0, 0, -16, 16);
                    processing.line(0, 0, -16, -16);

                    processing.popMatrix();
                }

                function drawEvents() {

                    processing.pushMatrix();

                    var eventCount = processing.eventLoop.events.length;
                    for (var i = 0; i < eventCount; i++) {
                        var loopEvent = processing.eventLoop.events[i];

                        processing.updatePosition(loopEvent);

                        // Draw the event node
                        processing.fill(66, 214, 146);
                        processing.ellipse(loopEvent.x, loopEvent.y, 60, 60);

                        // Calculate nearest point on circle
                        //line(loopEvent.x, loopEvent.y, screenWidth / 2, screenHeight / 2);
                    }

                    processing.popMatrix();
                }

                /**
                 * Updates position of event node.
                 * @param  {[type]} loopEvent [description]
                 * @return {[type]}           [description]
                 */
                function updatePosition(loopEvent) {

                    if (loopEvent.x !== loopEvent.xTarget || loopEvent.y !== loopEvent.yTarget) { // FREE
                        //console.log("Rendering ghost");
                    }
                    
                    // Check if event node is near to the event loop
                    // if (distance < 110) { // ENTANGLED
                    //     loopEvent.state = 'ENTANGLED';
                    // } else {
                    //     loopEvent.state = 'FLOATING';
                    // }

                    if (loopEvent.state === 'MOVING') {

                        // console.log(processing.mouseX);
                        // console.log($('#' + processing.canvas).offset());
                        console.log(1440 * (processing.deviceCount + 1) + processing.mouseX);
                        console.log(processing.mouseY);
                        // console.log($(processing.canvas).offset());

                        // Standard update for a moving event
                        console.log('MOVING' + (processing.deviceCount + 1));
                        
                        currentMouseX = 1440 * (processing.deviceCount + 1) + processing.mouseX;
                        loopEvent.x = currentMouseX;
                        loopEvent.y = processing.mouseY;

                        deltaX = currentMouseX - (processing.screenWidth / 2);
                        deltaY = processing.mouseY - (processing.screenHeight / 2);
                        angleInDegrees = Math.atan2(deltaY, deltaX);

                        loopEvent.xTarget = processing.screenWidth / 2 + (400 / 2) * Math.cos(angleInDegrees);
                        loopEvent.yTarget = processing.screenHeight / 2 + (400 / 2) * Math.sin(angleInDegrees);

                        // Check if under certain distance from the circle (and attach to)
                        var distance = processing.lineDistance(loopEvent.x, loopEvent.y, loopEvent.xTarget, loopEvent.yTarget);

                        if (distance < 110) { // ENTANGLED
                        //if (loopEvent.state === 'ENTANGLED') {
                            processing.line(loopEvent.x, loopEvent.y, loopEvent.xTarget, loopEvent.yTarget);

                            // Draw the "would be" position that the event node would occupy
                            processing.fill(66, 214, 146, 50);
                            processing.ellipse(loopEvent.xTarget, loopEvent.yTarget, 50, 50);

                            // Snap to event loop
                            if (!disableEventCreate) {
                                deltaX = processing.mouseX - (processing.screenWidth / 2);
                                deltaY = processing.mouseY - (processing.screenHeight / 2);
                                //angleInDegrees = Math.atan(deltaY / deltaX) * 180 / PI;
                                angleInDegrees = Math.atan2(deltaY, deltaX); // * 180 / PI;

                                loopEvent.x = processing.screenWidth / 2 + (400 / 2) * Math.cos(angleInDegrees);
                                loopEvent.y = processing.screenHeight / 2 + (400 / 2) * Math.sin(angleInDegrees);
                            }
                        }

                    } else if (loopEvent.state === 'FLOATING') {
                        processing.fill(66, 214, 146, 50);
                        processing.ellipse(loopEvent.x, loopEvent.y, 70, 70);
                    }
                }
                processing.updatePosition = updatePosition;

                /**
                 * Returns the sequence of events in the event queue.
                 * @return {[type]} [description]
                 */
                function getEventSequence() {
                    var eventSequence = [];

                    var eventCount = processing.eventLoop.events.length;

                    // Populate array for sorting
                    for (var i = 0; i < eventCount; i++) {
                        var loopEvent = processing.eventLoop.events[i];
                        if (loopEvent.state === 'SEQUENCED') {
                            loopEvent.go = function() { console.log("action " + i); }
                            eventSequence.push({
                                event: loopEvent,
                                angle: getAngle(loopEvent.x, loopEvent.y)
                            });
                        }
                    }

                    // Perform insertion sort
                    var i, j;
                    var loopEvent;
                    eventCount = eventSequence.length;
                    for (var i = 0; i < eventCount; i++) {
                        loopEvent = eventSequence[i];

                        for (j = i-1; j > -1 && eventSequence[j].angle > loopEvent.angle; j--) {
                            eventSequence[j+1] = eventSequence[j];
                        }

                        eventSequence[j+1] = loopEvent;
                    }

                    console.log(eventSequence);

                    for (var i = 0; i < eventSequence.length; i++) {
                        loopEvent = eventSequence[i];

                        loopEvent.event.go();
                    }

                    return eventSequence;
                }
                processing.getEventSequence = getEventSequence;

                function lineDistance(x1, y1, x2, y2) {
                    var xs = 0;
                    var ys = 0;

                    xs = x2 - x1;
                    xs = xs * xs;

                    ys = y2 - y1;
                    ys = ys * ys;

                    return Math.sqrt(xs + ys);
                }
                processing.lineDistance = lineDistance;

                function getPointOnCircle(radius, originX, originY, angle) {
                    //var radius = 50;
                    //var originX = 400;
                    //var originY = 400;
                    //var angle = 40;

                    x = originX + radius * Math.cos(angle);
                    y = originY + radius * Math.sin(angle);

                    var result = { x: x, y: y };

                    return result;
                }

                function getPosition(angle) {

                    var nearestX = processing.screenWidth / 2 + (400 / 2) * Math.cos(angle);
                    var nearestY = processing.screenHeight / 2 + (400 / 2) * Math.sin(angle);

                    var nearestPosition = {
                        x: nearestX,
                        y: nearestY
                    };
                    return nearestPosition;
                }
                processing.getPosition = getPosition;

                function getAngle(x, y) {
                    var deltaX = x - (processing.screenWidth / 2);
                    var deltaY = y - (processing.screenHeight / 2);
                    var angleInRadians = Math.atan2(deltaY, deltaX); // * 180 / PI;
                    if (angleInRadians < 0) {
                        angleInRadians = Math.PI + (Math.PI + angleInRadians);
                    }
                    angleInRadians = angleInRadians + (Math.PI / 2); // Offset by (PI / 2) radians
                    if (angleInRadians > (2 * Math.PI)) {
                        angleInRadians = angleInRadians - (2 * Math.PI);
                    }
                    return angleInRadians;
                }

                function getNearestPositionOnEventLoop(x, y) {
                    var deltaX = x - (processing.screenWidth / 2);
                    var deltaY = y - (processing.screenHeight / 2);
                    var angleInDegrees = Math.atan2(deltaY, deltaX); // * 180 / PI;

                    var nearestX = processing.screenWidth / 2 + (400 / 2) * Math.cos(angleInDegrees);
                    var nearestY = processing.screenHeight / 2 + (400 / 2) * Math.sin(angleInDegrees);

                    var nearestPosition = {
                        x: nearestX,
                        y: nearestY
                    };
                    return nearestPosition;
                }
                processing.getNearestPositionOnEventLoop = getNearestPositionOnEventLoop;

                function getDistanceFromEventLoop(loopEvent) {
                    var distance = processing.lineDistance(loopEvent.x, loopEvent.y, loopEvent.xTarget, loopEvent.yTarget);
                    return distance;
                }
                processing.getDistanceFromEventLoop = getDistanceFromEventLoop;

                /** Start of actual loop instructions. The things above are definitions. */

                // erase background
                processing.background(backgroundColor);

                // draw "go" button
                primaryFont = processing.createFont("DidactGothic.ttf", 32);
                processing.textFont(primaryFont, 100);
                processing.textAlign(processing.CENTER);
                processing.fill(65, 65, 65);
                processing.text("go", processing.screenWidth / 2, processing.screenHeight / 2 + 20);

                // draw script name
                primaryFont = processing.createFont("DidactGothic.ttf", 16);
                processing.textFont(primaryFont, 40);
                processing.textAlign(processing.CENTER);
                processing.fill(65, 65, 65);
                processing.text(scriptName, processing.screenWidth / 2, processing.screenHeight / 7 + 20);

                drawEventLoop();
                drawEvents();
            };
        });

        // deviceSketch.options.crispLines = true;
        this.processingInstance = new Processing(canvas, deviceSketch);
        this.processingInstance.canvas = canvas;
        this.processingInstance.deviceCount = deviceCount;
        // this.eventLoop = this.processingInstance.eventLoop;
        console.log(this.processingInstance);

        // var pi = new Processing("myCanvas");
        // pi.externals.sketch.options.crispLines = true;

        /**
         * Re-initialize Carousel after adding the new device pane
         */
        var carousel = new Carousel("#carousel");
        carousel.init();
        carousel.showPane(deviceCount);

        // /**
        //  * Setup gestures
        //  */

        // jqCanvas = "#" + canvas;
        // setupGestures(jqCanvas, this);
    }
    
    // Create medium
    // var medium = new Medium();
    // medium.devices.push(device);    

    // Add device
    // var device = new Device();
    // devices.push(device);

    /**
     * Setup gestures
     */

    // jqCanvas = "#" + device.canvas;
    // setupGestures(jqCanvas, device);



    // var device = new Device();
    // jqCanvas = "#" + device.canvas;
    // setupGestures(jqCanvas, device);

    function addDevice() {

        deviceCount = deviceCount + 1;
        $('#panes').append('<li class="pane' + deviceCount + '"><canvas id="canvas' + deviceCount + '" style="width: 100%; height: 100%;"></canvas></li>');
        canvas = "canvas" + deviceCount;

        var device = new Device({ canvas: canvas });
        jqCanvas = "#" + device.canvas;
        setupGestures(jqCanvas, device);
    }

    addDevice();
    addDevice();



    </script>

</body>
</html>
